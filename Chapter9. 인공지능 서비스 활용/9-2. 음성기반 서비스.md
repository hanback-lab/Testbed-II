# 음성 인식
음성 인식(Speech Recognition)은 인간의 음성을 분석하여 컴퓨터가 이해할 수 있는 텍스트나 명령으로 변환하는 기술입니다.

스마트 스피커, 음성 비서, 차량용 음성 제어 시스템 등 다양한 장치에서 활용되며, 사람과 기계 간 상호작용을 더욱 자연스럽게 만들어줍니다.

특히 프로그래밍 환경에서는 마이크 입력을 기반으로 특정 단어를 인식하거나 장치를 직접 제어하는 등, 실습과 응용 범위가 매우 넓습니다.

## SpeechRecognition
SpeechRecognition 패키지는 STT(Speech To Text) 패키지들 중 가장 대표적인 라이브러리입니다. 이 패키지는 Host PC의 마이크 및 오디오 파일을 통해 음성 데이터를 확보한 후, 이를 음성인식 API와 통신하여 음성 데이터를 텍스트로 변환해줍니다.

또한, 간편한 설치와 함께 Google, Azure, OpenAI 등 다양한 STT API 서버를 지원합니다. 이 중 일부는 별도의 추가 설정 없이 바로 활용하실 수 있습니다.
본 매뉴얼에서는 Google Speech API를 활용하여 실습을 진행합니다. 다만, 기본 제공되는 무료 사용량은 한정되어 있으므로, 한도를 초과하면 기능 사용이 제한됩니다.

## SpeechRecognition 설치 
다음 명령을 이용해 필수 패키지를 설치합니다.

```sh
> pip install PyAudio
> pip install SpeechRecognition==3.9.0
```

## 첫번째 음성 인식 
처음으로 작성하는 예제는 SpeechRecognition 라이브러리를 사용하여 마이크로부터 입력된 음성을 텍스트로 변환(STT) 하는 가장 기본적인 구조를 보여줍니다.

Recognizer() 객체는 음성 인식의 핵심 역할을 담당하며, 마이크에서 수집된 오디오 데이터를 처리하고 외부 음성 인식 API와 통신하는 기능을 제공합니다.

with sr.Microphone() as source: 구문은 시스템에 연결된 기본 마이크를 입력 장치로 설정하고, 사용자가 말하는 동안의 음성 신호를 안정적으로 수집하기 위한 환경을 구성합니다.

recognizer.listen(source)는 사용자의 발화를 감지하여 음성 구간을 녹음하고, 해당 음성을 audio 객체로 반환합니다.

이후 recognize_google() 함수를 통해 녹음된 음성을 전송하여 텍스트로 변환하며, 음성이 인식되지 않거나 네트워크 또는 API 오류가 발생할 경우를 대비해 예외 처리를 통해 오류 원인을 명확히 출력하도록 구성되어 있습니다.

```python
import speech_recognition as sr

recognizer = sr.Recognizer()

with sr.Microphone() as source:
    print("Please speech...")
    audio = recognizer.listen(source)

try:
    print("Recognized text: " + recognizer.recognize_google(audio, language='en-US'))
except sr.UnknownValueError:
    print("Google Web Speech API can't understand your speech")
except sr.RequestError as e:
    print(f"Google Web Speech API has something error : {e}")
```

## 음성 인식 후 키워드 추출하기
이 예제는 앞선 음성 인식 과정을 확장하여, 인식된 텍스트로부터 특정 키워드를 추출하고 해석하는 단계를 추가한 구조입니다.

음성 인식이 완료되면 변환된 텍스트는 text_parsing() 함수로 전달되며, 이 함수는 문자열 내부에 포함된 키워드를 기준으로 사용자의 의도를 판별합니다.

text_parsing() 함수는 입력된 문장을 전처리한 뒤, 'forward', 'backward', 'stop'과 같은 사전에 정의된 명령어가 포함되어 있는지를 순차적으로 검사합니다.

만약 해당 키워드 중 하나가 발견되면, 해당 문자열을 반환하여 이후 제어 로직이나 상태 처리에 활용할 수 있도록 하고, 어떤 키워드도 포함되지 않은 경우에는 None을 반환하여 유효하지 않은 명령임을 나타냅니다.

이 구조를 통해 음성 인식 결과를 단순히 출력하는 데서 그치지 않고, 음성 → 텍스트 → 의미 있는 명령으로 해석하는 과정을 명확하게 구분하여 이해할 수 있습니다.

```python
import speech_recognition as sr

def text_parsing(text):
    text = text.strip()

    if 'forward' in text:
        return 'forward'
    elif 'backward' in text:
        return 'backward'
    elif 'stop' in text:
        return 'stop'
    else:
        return None

recognizer = sr.Recognizer()

with sr.Microphone() as source:
    print("Please speech...")
    audio = recognizer.listen(source)

try:
    text = recognizer.recognize_google(audio, language='en-US')
    print("Recognized text : " + text)
    print("Parsing text : " + str(text_parsing(text)))
except sr.UnknownValueError:
    print("Google Web Speech API can't understand your speech")
except sr.RequestError as e:
    print(f"Google Web Speech API has something error : {e}")
```

## 음성기반 도어락 제어 
아래 코드는 마이크로 입력된 음성을 텍스트로 변환한 뒤, 그 텍스트 안에 포함된 키워드를 기준으로 도어락을 열거나 닫는 제어 함수를 호출하는 예제입니다.

DoorLock() 객체는 TestBed의 도어락 액츄에이터를 제어하기 위한 인터페이스로, open() / close() 같은 메서드를 통해 실제 장치(또는 에뮬레이터)에 제어 요청을 전달합니다.

text_parsing() 함수는 인식된 문장을 전처리(공백 제거, 필요 시 소문자 변환)한 후, 문장에 'door'라는 대상 키워드가 포함되어 있는지를 먼저 확인하고, 그 다음 'open' 또는 'close' 동작 키워드가 있는지 검사하여 알맞은 제어를 수행합니다.

while True 루프는 프로그램이 종료되기 전까지 계속해서 음성을 입력받기 위한 구조로, 사용자가 말을 하면 recognizer.listen()이 음성 구간을 수집해 audio로 저장하고, 이 audio를 STT 함수로 전달해 텍스트를 얻는 흐름으로 동작합니다.

즉, 이 예제의 핵심은 (1) 음성 수집 → (2) 텍스트 변환(STT) → (3) 키워드 기반 의도 판별 → (4) 액츄에이터 제어 호출의 파이프라인을 직접 경험하는 것이며, 이후에는 오인식 대비를 위한 예외 처리, 소음 보정, 확인(confirmation) 절차 같은 안전 장치를 추가해 실제 시스템 수준으로 확장할 수 있습니다.

```python
import speech_recognition as sr
from testbed.actuator import DoorLock 

door = DoorLock()

def text_parsing(text):
    text = text.strip()

    if 'door' in text:
        if 'open' in text:
            door.open()
        elif 'close' in text:
            door.close()

recognizer = sr.Recognizer()

while True:
    with sr.Microphone() as source:
        print("Please speech...")
        audio = recognizer.listen(source)
```