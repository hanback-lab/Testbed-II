# TestBed 개요 
IoT 센서가 부착된 장비는 온도, 습도, 압력, 진동 등 다양한 데이터를 실시간으로 수집하여 전송하며, 이렇게 수집된 데이터를 분석함으로써 생산 공정의 효율성을 극대화하고 불량률을 감소시키며 생산량을 최적화할 수 있습니다.   
또한, IoT 데이터 기반의 공정 자동화를 통해 특정 조건 충족 시 기계의 자동 작동 또는 정지 설정이 가능해져 인적 오류를 줄이고 생산 속도를 향상시킬 수 있으며, 장비 상태를 실시간으로 모니터링하여 고장을 사전에 예측하고 예방함으로써 장비 수명 연장 및 갑작스러운 고장으로 인한 생산 차질을 최소화합니다.

# 장치 제어 프로그래밍 
TestBed은 가정, 사무실, 공장 등에 설치된 인터넷 기반 자동 설비 제어에 필요한 소프트웨어 기술 학습을 위한 플랫폼입니다. HMI와 Auto 제어기, Auto 제어기용 주변장치 등으로 구성됩니다.  

## pop-testbed
pop-testbed 은 TestBed 제어를 위한 파이썬 라이브러리 입니다. pip 를 통해 손쉽게 설치하여 사용할 수 있습니다. 

```sh
pip install pop-testbed 
```

pop-testbed 에서 제공되는 각종 클래스 및 메소드의 상세 설명은 아래 링크를 확인하시기 바랍니다. 

- [Pop TestBed API Documents](https://github.com/hanback-lab/Testbed-II/blob/main/ETC/A.%20Pop%20API.md)

### 연결 설정 파일 생성 
pop-testbed 활용에 앞서 연결 설정 파일을 생성합니다. 접속할 브로커의 주소, 장비 고유번호, 등의 정보를 "product" 파일로 저장하고 해당 정보를 읽어 활용합니다. 아래는 작성 예시입니다.

```conf
BROKER_DOMAIN=192.168.50.2
CAMERA_DOMAIN=192.168.50.2
DEVICE_NAME=TB
DEV_NUM=01
INSITUTION_NAME=HBE
```

- BROKER_DOMAIN : 접속할 브로커의 주소를 입력합니다. TestBed의 HMI IP를 입력합니다.
- DEVICE_NAME : 장비의 이름으로 TestBed 은 'TB' 으로 기본 설정되어 있습니다. 
- DEV_NUM : 장치의 고유 번호로 여러개의 장비가 존재하는 경우에는 이 번호를 중복되지 않게 설정해야 합니다. 
- INSITUTION_NAME : 학교 또는 기관의 명칭을 고유 키워드로 활용합니다. 

여기서 INSITUTION_NAME 은 출고되는 TestBed 마다 다르게 설정되어 있으며 이 정보는 TestBed 후면에 기록되어 있습니다. 또는 TestBed의 HMI 에서 정보를 확인할 수 있습니다. 

<details>
<summary>HMI ISITUTION NAME 확인</summary>

1. 터미널 실행   
    - `Win + x`를 눌러 표시되는 작업 표시줄 메뉴에서 '터미널' 을 실행합니다. 

2. SSH 접속  
    - 터미널 창에서 아래와 같이 명령어를 입력합니다.

```sh 
ssh soda@192.168.50.2
```

3. 다음 명령을 통한 명칭 확인   
    - 다음 명령을 입력하여 출력되는 내용중 `INSITUTION_NAME` 을 확인하여 작성중인 product 파일에 적용합니다. 

```sh 
cat /etc/product 

ex) 
BROKER_DOMAIN=127.0.0.1
CAMERA_DOMAIN=127.0.0.1
DEVICE_NAME=TB
DEV_NUM=01
INSITUTION_NAME=KUS
```

</details>
  
<br/>

   
이 명칭을 정확하게 기입해야 이후 제어 프로그램 실행하는 과정에서 정상적인 제어를 진행할 수 있습니다. 

## Actuator 제어 

### 조명 제어 
TestBed에 장착되어 있는 조명은 3개입니다. 각각 현관, 주방, 침실에 있으며 켜기 혹은 끄기 동작으로 제어할 수 있습니다. 조명은 TestBed 라이브러리의 Lamp 클래스를 통해 제어할 수 있습니다. on()과 off() 메소드를 통해 제어가 가능하며 코드는 다음과 같습니다. 

```python
from testbed.actuator import Lamp
import time

lamp = Lamp('entrance') 

lamp.on()
time.sleep(1)
lamp.off()
```

클래스 생성시 제어할 구역을 지정하여 전달합니다. 지정 가능한 구역은 다음과 같습니다. 

- 현관 : entrance
- 주방 : kitchen 
- 침실 : room 

on() 메소드와 off() 를 통해 제어 합니다. 

Lamp 클래스의 state를 통해 조명의 제어 피드백 신호를 확인할 수 있습니다. state의 정보는 딕셔너리 형태로 반환되며 {'ts':'TimeStamp', 'state':'LampState'} 형태입니다. TimeStamp는 제어 명령이 발생한 시각이며, state는 실제 제어 결과입니다. on() 을 통해 켜는 명령을 내렸을때, 실제 Lamp가 켜지지 않는다면 state 는 ON이 아닌 OFF 가 전달됩니다.  

```python
lamp.on()
time.sleep(1)
print(lamp.state)
lamp.off()
time.sleep(1)
print(lamp.state)
```

```out
{'ts': 1609467370, 'state': 'ON'}
{'ts': 1609467371, 'state': 'OFF'}
```

동시에 여러개의 조명을 제어하고 싶다면 각각 인스턴스를 생성하여 활용하면되지만 LampGroup 클래스를 활용해도 됩니다. 

```python
from testbed.actuator import LampGroup
import time 

lg = LampGroup()
lg.on()
time.sleep(1)
print(lg.state)
lg.off('kitchen')
time.sleep(1)
print(lg.state)
```

```out
{'ENTRANCE': {'ts': 1609467581, 'state': 'ON'}, 'ROOM': {'ts': 1609467581, 'state': 'ON'}, 'KITCHEN': {'ts': 1609467581, 'state': 'ON'}}
{'ENTRANCE': {'ts': 1609467581, 'state': 'ON'}, 'ROOM': {'ts': 1609467581, 'state': 'ON'}, 'KITCHEN': {'ts': 1609467582, 'state': 'OFF'}}
```

Lamp 클래스와 동일하게 on()과 off()를 통해 켜고 끄는 작업을 실행할 수 있습니다. 다만, 메소드 호출시 인자를 아무것도 전달하지 않으면 TestBed 에 장착된 모든 조명에 제어 명령이 전달되며, 특정 구역을 제어하고 싶다면 메소드 호출시 구역의 명칭을 지정하면됩니다. 

### 환기팬 제어
TestBed에 장착되어 있는 환기팬은 2개입니다. 각각 주방, 침실에 있으며 켜기 혹은 끄기 동작으로 제어할 수 있습니다. 환기팬은 testbed 라이브러리의 Fan 클래스를 통해 제어할 수 있습니다. on()과 off() 메소드를 통해 제어가 가능하며 코드는 다음과 같습니다. 

```python
from testbed.actuator import Fan
import time

fan = Fan('kitchen') 

fan.on()
time.sleep(3)
fan.off()
```

클래스 생성시 제어할 구역을 지정하여 전달합니다. 지정 가능한 구역은 다음과 같습니다.

- 주방 : kitchen 
- 침실 : room 

on() 메소드와 off() 를 통해 제어 합니다. 

Fan 클래스의 state를 통해 조명의 제어 피드백 신호를 확인할 수 있습니다. state의 정보는 딕셔너리 형태로 반환되며 {'ts':'TimeStamp', 'state':'LampState'} 형태입니다. TimeStamp는 제어 명령이 발생한 시각이며, state는 실제 제어 결과입니다. on() 을 통해 켜는 명령을 내렸을때, 실제 Lamp가 켜지지 않는다면 state 는 ON이 아닌 OFF 가 전달됩니다.  

```python
fan.on()
time.sleep(1)
print(fan.state)
fan.off()
time.sleep(1)
print(fan.state)
```

```out
{'ts': 1609468324, 'state': 'ON'}
{'ts': 1609468325, 'state': 'OFF'}
```

### 출입문 제어
현관에 출입문은 DoorLock 클래스를 통해 제어할 수 있으며, open(), close() 메소드를 통해 제어합니다. 

```python
from testbed.actuator import DoorLock
import time

doorlock = DoorLock()

for i in range(3):
    doorlock.open()
    time.sleep(5)
    doorlock.close()
    time.sleep(5)
```

state를 통해 출입문 제어 상태를 확인할 수 있습니다. 상태는 열림, 중간, 닫힘의 세 가지로 구분됩니다. 

```python
doorlock.open()
for i in range(5):
    print(doorlock.state)
    time.sleep(1)

doorlock.close()
for i in range(5):
    print(doorlock.state)
    time.sleep(1)
```

```out
{'ts': 1609468324, 'state': 'OPEN'}
{'ts': 1609468325, 'state': 'OPEN'}
{'ts': 1609468326, 'state': 'OPEN'}
{'ts': 1609468327, 'state': 'OPEN'}
{'ts': 1609468328, 'state': 'OPEN'}
{'ts': 1609468329, 'state': 'CLOSE'}
{'ts': 1609468330, 'state': 'CLOSE'}
{'ts': 1609468331, 'state': 'CLOSE'}
{'ts': 1609468332, 'state': 'CLOSE'}
{'ts': 1609468333, 'state': 'CLOSE'}
```

### 가스차단기 제어
주방에 가스차단기는 GasBreaker 클래스를 통해 제어할 수 있으며, open(), close() 메소드를 통해 제어합니다. 

```python
from testbed.actuator import GasBreaker
import time

gasbreaker = GasBreaker()

for i in range(3):
    gasbreaker.open()
    time.sleep(7)
    gasbreaker.close()
    time.sleep(7)
```

state를 통해 가스차단기 제어 상태를 확인할 수 있습니다. 상태는 3가지 상태로 열림, 중간, 닫힘으로 구분됩니다.  

```python
gasbreaker.open()
time.sleep(0.5)
print(gasbreaker.state)

gasbreaker.close()
time.sleep(0.5)
print(gasbreaker.state)
```

```out
{'ts': 1609476125, 'state': 'OPEN'}
{'ts': 1609476127, 'state': 'CLOSE'}
```

### 커튼 제어
커튼은 Curtain 클래스를 통해 제어할 수 있으며, open(), close(), stop() 메소드를 통해 제어합니다. 

```python
from testbed.actuator import Curtain
import time

curtain = Curtain()

curtain.open()
time.sleep(2)
curtain.stop()
time.sleep(2)
curtain.open()
time.sleep(2)
curtain.close()
time.sleep(2)
curtain.stop()
time.sleep(2)
curtain.close()
time.sleep(2)
```

state를 통해 커튼 제어 상태를 확인할 수 있습니다. 상태는 3가지 상태로 열림, 중간, 닫힘으로 구분됩니다.  

```python
curtain.open()
for i in range(4):
    print(curtain.state)
    time.sleep(1)

curtain.close()
for i in range(4):
    print(curtain.state)
    time.sleep(1)
```

```out
{'ts': 1609476125, 'state': 'OPENING'}
{'ts': 1609476126, 'state': 'OPENING'}
{'ts': 1609476127, 'state': 'OPENING'}
{'ts': 1609476128, 'state': 'OPENED'}
{'ts': 1609476129, 'state': 'CLOSING'}
{'ts': 1609476130, 'state': 'CLOSING'}
{'ts': 1609476131, 'state': 'CLOSING'}
{'ts': 1609476132, 'state': 'CLOSED'}
```

## Sensor 데이터 수신 

### PIR 센서 데이터 읽기 
PIR 센서는 현관에 위치하고 있으며 사람이나 동물의 움직임을 감지합니다. testbed 라이브러리의 Pir 클래스를 통해 현재 센서값을 확인할 수 있습니다. 

```python
from testbed.sensor import Pir 
import time 

pir = Pir() 

for i in range(100):
    print(pir.read())
    time.sleep(0.1)
```

```out
{'ts': 1609468424, 'state': '0'}
{'ts': 1609468424, 'state': '0'}
{'ts': 1609468424, 'state': '0'}
{'ts': 1609468424, 'state': '0'}
{'ts': 1609468424, 'state': '1'}
{'ts': 1609468424, 'state': '1'}
{'ts': 1609468424, 'state': '1'}
{'ts': 1609468424, 'state': '1'}
{'ts': 1609468425, 'state': '1'}
{'ts': 1609468425, 'state': '0'}
{'ts': 1609468425, 'state': '0'}
...중략...
```

### Light 센서 데이터 읽기 
Light 센서는 3개에 구역에 각각 위차하고 있으며 주변의 밝기를 감지하여 룩스(lx) 값을 반환합니다. Light 클래스를 통해 현재 센서값을 확인할 수 있습니다. 

```python
from testbed.sensor import Light 
import time 

light = Light('kitchen') 

for i in range(100):
    print(light.read())
    time.sleep(0.1)
```

```out
{'ts': 1609469030, 'state': 4}
{'ts': 1609469031, 'state': 4}
{'ts': 1609469031, 'state': 4}
{'ts': 1609469031, 'state': 230}
{'ts': 1609469031, 'state': 237}
{'ts': 1609469031, 'state': 237}
{'ts': 1609469031, 'state': 237}
...중략...
```

LightGroup 클래스는 TestBed에 장착된 모든 Light 센서 데이터를 한번에 수신하여 출력할 수 있습니다. 

```python
from testbed.sensor import LightGroup 
import time 

light = LightGroup() 

for i in range(100):
    print(light.read())
    time.sleep(0.1)
```

```out
{'ENTRANCE': {'ts': 1609469130, 'state': 175}, 'ROOM': {'ts': 1609469130, 'state': 195}, 'KITCHEN': {'ts': 1609469130, 'state': 4}}
{'ENTRANCE': {'ts': 1609469130, 'state': 175}, 'ROOM': {'ts': 1609469130, 'state': 195}, 'KITCHEN': {'ts': 1609469130, 'state': 4}}
{'ENTRANCE': {'ts': 1609469130, 'state': 143}, 'ROOM': {'ts': 1609469130, 'state': 195}, 'KITCHEN': {'ts': 1609469130, 'state': 4}}
{'ENTRANCE': {'ts': 1609469130, 'state': 143}, 'ROOM': {'ts': 1609469130, 'state': 195}, 'KITCHEN': {'ts': 1609469130, 'state': 4}}
{'ENTRANCE': {'ts': 1609469130, 'state': 143}, 'ROOM': {'ts': 1609469130, 'state': 195}, 'KITCHEN': {'ts': 1609469130, 'state': 4}}
...중략...
```

### TPHG 센서 데이터 읽기 
TPHG 센서는 3구역에 모두 배치되어있으며 4가지 센서데이터를 반환합니다. Tphg 클래스를 통해 현재 센서값을 확인할 수 있습니다. 반환되는 데이터는 딕셔너리 형태로 각 센서 이름이 키가 되며, 각 키에 해당하는 값이 함께 반환됩니다.

```python
from testbed.sensor import Tphg 
import time 

tphg = Tphg('room') 

for i in range(10):
    print(tphg.read())
    time.sleep(1)
```

```out
{'ts': 1609477276, 'temp': 19.32, 'humi': 12.32, 'press': 1012.68, 'gas': 12887}
{'ts': 1609477277, 'temp': 19.32, 'humi': 12.32, 'press': 1012.69, 'gas': 12887}
{'ts': 1609477277, 'temp': 19.32, 'humi': 12.32, 'press': 1012.69, 'gas': 12887}
{'ts': 1609477279, 'temp': 19.31, 'humi': 12.31, 'press': 1012.69, 'gas': 12887}
{'ts': 1609477280, 'temp': 19.31, 'humi': 12.33, 'press': 1012.69, 'gas': 12887}
{'ts': 1609477281, 'temp': 19.3, 'humi': 12.33, 'press': 1012.68, 'gas': 12887}
...중략...
```

TphgGroup 클래스를 통해 TestBed의 TPHG 센서 데이터를 한번에 수신할 수 있습니다. 아래 예시는 TPHG 센서 데이터를 한번에 수신하여 그중 ROOM 과 KITCHEN 의 온도 데이터를 출력한 예시입니다. 

```python
from pop_plus.sensor import TphgGroup
import time 

tphg = TphgGroup() 

for i in range(10):
    try:
        tphg_value = tphg.read()
        print(tphg_value['ROOM']['temp'],tphg_value['KITCHEN']['temp'])
    except:
        pass
    time.sleep(1)
```

```out
19.51 19.52
19.51 19.52
19.5 19.52
19.5 19.51
19.5 19.51
...중략...
```

### Dust 센서 데이터 읽기 
Dust 센서는 ROOM 에 위차하고 있으며 3가지 크기의 미세먼지를 측정하여 반환합니다. 각각 1.0μm, 2.5μm, 10μm 크기 이며 측정 단위는 µg/m³ 또는 TSI 단위를 사용합니다. Dust 클래스를 통해 센서값을 확인할 수 있습니다. 반환되는 데이터는 딕셔너리 형태로 각 미세먼지 측정 크기가 키값을 이루고 있으며 해당 키에 맞는 데이터를 쌍으로 가집니다. 

```python
from testbed.sensor import Dust 
import time 

dust = Dust() 

for i in range(10):
    print(dust.read())
    time.sleep(1)
```

```out
{'ts': 1609478576, 'pm1_0': 11, 'pm2_5': 11, 'pm10': 11}
{'ts': 1609478577, 'pm1_0': 10, 'pm2_5': 10, 'pm10': 10}
{'ts': 1609478578, 'pm1_0': 11, 'pm2_5': 11, 'pm10': 11}
{'ts': 1609478578, 'pm1_0': 11, 'pm2_5': 11, 'pm10': 11}
{'ts': 1609478579, 'pm1_0': 11, 'pm2_5': 11, 'pm10': 11}
{'ts': 1609478579, 'pm1_0': 11, 'pm2_5': 11, 'pm10': 11}
...중략...
```

### GasDetector 데이터 읽기 
GasDetector 센서는 KITCHEN에 위차하고 있으며 주변의 가스를 감지합니다. GasDetector 클래스를 통해 현재 센서값을 확인할 수 있습니다. GasDetector 는 상태가 변경되었을때 Auto 제어기로 부터 데이터가 발생하며, 같은 상태가 유지된다면 5초마다 데이터가 갱신되도록 되어 있습니다. 

```python
from testbed.sensor import GasDetector 
import time 

gas = GasDetector() 

for i in range(30):
    print(gas.read())
    time.sleep(1)
```

```out
{'ts': 1609480618, 'state': 0}
{'ts': 1609480619, 'state': 0}
{'ts': 1609480620, 'state': 0}
{'ts': 1609480621, 'state': 0}
{'ts': 1609480622, 'state': 1}
{'ts': 1609480623, 'state': 1}
...중략...
```

## PIXBOARD 제어 

### 전광판 제어 
TestBed에는 문자를 표현할 수 있는 전광판이 포함되어 있습니다. 전광판에는 원하는 문자를 표현할 수 있으며 색상을 지정할 수도 있습니다. 또한 표현한 문자를 원하는 속도와 방향으로 이동도 가능한 기능을 포함합니다. 상세한 API 기능은 서두에 소개된 API 문서를 참조하시기 바랍니다. 

전광판 제어는 testbed 라이브러리의 Pixboard 클래스를 활용합니다. 다음은 예시는 간단하게 문자를 출력한 예시입니다. 

```python
from testbed.pixboard import Pixboard

pb = Pixboard() 

pb.text('hello world')
```

글자의 색상은 textColor(), 글자의 배경은 bgColor() 를 통해 변경이 가능합니다. 색상정보는 리스트로 전달하며, [빨강, 초록, 파랑] 순서로 0~255 사이의 숫자를 전달합니다. 

```python
from testbed.pixboard import Pixboard

pb = Pixboard() 

pb.text('Color Test')
pb.textColor([20,0,10])
pb.bgColor([0,20,0])
```

전광판에 표기된 글자를 원하는 방향으로 자동 이동하도록 설정할 수 있습니다. shift() 메소드를 활용하면됩니다. 인자로 shift_dir 에 "left" 또는 "right"를 통해 이동하는 방향을 설정할 수 있으며, shift_speed 에 이동 속도를 지정합니다. 속도는 ms 단위 입니다. 

```python
from testbed.pixboard import Pixboard

pb = Pixboard() 

pb.text('Text Shift Test')
pb.textColor([20,0,10])
pb.bgColor([0,20,0])
pb.shift(shift_dir="left", shift_speed=10)
```
